# PyTLidar

PyTLidar is a python module designed for manipulating and calculating metrics from terrestrial lidar data. Version 1 makes the TreeQSM[link] capabilites available through Python, eliminating the need for proprietary tools. Development of version 2.0 is in progress to enhance the capabilities with tree segmentation, calculation of digital elevation models, and detailed environmental measurements at scale.



# Installation

The release version of PyTLiDAR can be installed as a standard python package

```
pip install PyTLiDAR
```
# Development Installation

If you are contributing to PyTLiDAR or would like to try one of the experimental packages, you may install following these instructions:

In your terminal navigate to the folder you want to clone this repo into and clone with 
```
git clone https://github.com/Landscape-CV/PyTLiDAR.git
cd PyTLiDAR
```
## Create a .venv & requirements installed
### Mac
```
python -m venv .venv
. .venv/bin/activate
pip install -r requirements.txt
```
### Windows
```
python -m venv .venv
. .venv/Scripts/activate
pip install -r requirements.txt
```
### CSF Dependency (Ecomodel Only)

The Ecomodel framework is dependent on the Cloth Simulation Filter ground filtering algorithm available here:
https://github.com/jianboqi/CSF

This version has not been updated to work with Numpy version >=2.0, so you will need to recompile it locally using the following instructions:

Download the above repository
Locate the file pyproject.toml and replace the contents with the following:
```
`[build-system]
requires = ["wheel","setuptools", "numpy>=2.0.0rc1"]
dependencies = ["oldest-supported-numpy"]
build-backend = "setuptools.build_meta"

[tool.cibuildwheel]
build = "cp3{8,9,10,11,12}-*" `
```
Run ```python setup.py bdist_wheel ```
(make sure you have installed setuptools wheel using pip install setuptools wheel)

you can then run 
```pip install dist/<name of the generated file>```

You will then be able to run the ecomodel framework.

# TreeQSM

### TreeQSM Application Usage

To launch the GUI application run
```
python -m PyTLiDAR.main
```


The below interface will appear, with instructions for generating your QSM models.
You may choose to run a single file or multiple, with the ability to view the point cloud and results on the subsequent screen.


![Software interface for user input and data selection. \label{fig:pc1}](paper/figs/fig1.jpg)


We also provide multiple command line interface options using PyTLiDAR.treeqsm and PyTLiDAR.treeqsm_batch

You may run the following your terminal

```
python -m PyTLiDAR.treeqsm file.las
```
or to run a full folder of las files in batch mode
```
python -m PyTLiDAR.treeqsm_batch folder
```
The below arguments can also be passed to provide full functionality 

    -intensity: filter point cloud based on values greater than the indicated intensity

    -normalize: recenter point cloud locations. Use this if your point cloud X, Y location values are very large (e.g., using UTM coordinates rather than a local coordinate system).

    -custominput: user sets specific patch diameters to test

    -ipd: initial patch diameter

    -minpd: min patch diameter

    -maxpd: maximum patch diameter

    -name: specifies a name for the current modeling run. This will be appended to the name generated by PyTLiDAR

    -outputdirectory: specifies the directory to put the "results" folder

    -numcores: specify number of cores to use to process files in parallel. Only valid in batched mode, Must be a single integer

    -optimum: specify an optimum metric to select best model to save 

    -help: displays the run options

    -verbose: verbose mode, displays outputs from PyTLiDAR as it processes

    -h: displays the run options

    -v: verbose mode

Examples:

1. Create a QSM for a single file, normalizing the file, and using 2 initial patch diameter values generated based on structural assumptions
```
python -m PyTLiDAR.treeqsm file.las --normalize --ipd 2
```
2.  Create a QSM for multiple files, with normalization, testing a specific set of patch diameter values, saving only the best model based on lowest mean distance to trunk
```
python -m PyTLiDAR.treeqsm_batch folder --normalize --custominput --ipd .05 .08 --minpd .03 .05 --maxpd .1 --optimum trunk_mean_dis
```

### TreeQSM Module Quick Start

Below is the algorithm sequence of the TreeQSM process on a single file and testing a single set of values. See treeqsm.py for a full implementation.
```
import PyTLiDAR.treeqsm as qsm


file = 'example_pine.las'

P = qsm.Utils.load_point_cloud(file) #Load las file

P = P - np.mean(P,axis = 0) #Normalize points

Inputs = define_input(P, 1, 1, 1)[0] #Create input parameter structure
# Inputs can be specified 
Inputs['PatchDiam1'] = [0.05] #Initial size of cover sets, lower values will capture more detail, but are more susceptible to occlusion
Inputs['PatchDiam2Min'] = [0.03] #Minimum cover set size for second pass
Inputs['PatchDiam2Max'] = [0.12] #Maximum cover set size for second pass
Inputs['BallRad1'] = [0.06] #radius around cover set midpoint to check for neighbors, should be slightly larger than PatchDiam1
Inputs['BallRad2'] = [0.13] #Ball Radius for second pass, should be slightly larger than PatchDiam2Max
Inputs['plot'] = 0 #Flag for plot generation during runtime

cover1 = qsm.cover_sets(P,Inputs) #Generate initial cover sets and neighbors
cover1, Base, Forb = qsm.tree_sets(P, cover1, Inputs) #Tree set generation/detection of base points
segment1 = qsm.segments(cover1,Base,Forb) #Segment generation
segment1 = qsm.correct_segments(P,cover1,segment1,Inputs,0,1,1) #Segment Correction
RS = qsm.relative_size(P, cover1, segment1) #Calculation of relative size for generation of new cover sets
cover2 = qsm.cover_sets(P, Inputs, RS) # Cover set Generation, 2nd Pass
cover2, Base, Forb = qsm.tree_sets(P, cover2, Inputs, segment1) # Tree set generation
segment2 = qsm.segments(cover2, Base, Forb) #Segment Generation, 2nd Pass
segment2 = qsm.correct_segments(P, cover2, segment2, Inputs, 1, 1, 0)#Segment correction, 2nd Pass
cylinder = qsm.cylinders(P,cover2,segment2,Inputs) #Fit Cylinders
branch = qsm.branches(cylinder)#Calculate branch metrics
#Extract Trunk points:
T = segment2['segments'][0]  
T = np.concatenate(T)  
T = np.concatenate([cover2['ball'][idx] for idx in T]) 
trunk = P[T, :]  # Point cloud of the trunk
treedata, _ = qsm.tree_data(cylinder, branch, trunk, inputs,iter )

```
# Tests

Run the tests using pytest:
```
pytest
```

This will run all the test cases under the tests/ directory. The tests include basic functionality checks for the core components of QSM creation.

You can also run specific tests by passing the test file or function name:

pytest tests/test_calculate.py

Due to the complex nature of inputs and outputs of the algorithm, manual tests are also recommended. Using Dataset/example_pine.las run:

```
python -m PyTLidar.treeqsm example_pine.las --normalize --verbose 
```

Compare the tree_data_Tree1_t1_m1.txt file that is generated to Dataset/results/example_pine_tree_data.txt. The algorithm is randomized, so many values will not match, but no value should be significantly different. 

This test can also be run using the GUI, and a visual check can also be done as a sanity check on the resulting numbers.
# Under Development

Below are functionalities that are under active development to be included in future pip versions.
## Tree Segmentation

## Graph-Based Leaf Separation

## Region Growing Leaf Separation

## Ecomodel
Ecomodel is an experimental module intended to provide detailed metrics for complex environments

### Create a .env file
make a file in your parent director named `.env` and paste the following into it replace the ... with the filepath to your data
```
DATA_FOLDER_FILEPATH = ...
```
# Contributing
## Reporting Bugs

Submit a Report: You may submit your bug report to issues. Please include any relevant output.
Check to see if your issue has already been reported, commenting on the issue may help pinpoint the fix and also elevate the priority.

## Suggestions

Share your thoughts: You may submit your idea in issues as well. The more descriptive the better, but minor usability suggestions are welcome.

## Development

### Contributing Fixes

You may create a fork of our repository to submit a pull request. Your request will be reviewed and if approved will be incorporated. For best chances at approval, attach to an existing issue or create your own to resolve. 

### Contributing New Features

If you have a simple feature to add, you may follow the same procedure as contributing a fix. However, if you have a larger feature, collaboration with the broader team may be warranted. If you feel this is the case, please reach out to someone on the dev team and a plan can be developed for your collaboration and certain permissions may be granted. 

# License

PyTLidar is published under the GPL 3.0 License 
