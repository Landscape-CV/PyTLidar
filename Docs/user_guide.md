
# Installation

The release version of PyTLidar can be installed as a standard python package

```
pip install PyTLidar
```





# TreeQSM

### TreeQSM Application Usage: GUI

To launch the GUI application run
```
python -m PyTLidar.main
```


The below interface will appear, with instructions for generating your QSM models.
You may choose to run a single file or multiple, with the ability to view the point cloud and results on the subsequent screen.


![Software interface for user input and data selection. \label{fig:pc1}](paper/figs/fig1.jpg)


### TreeQSM Application Usage: CLI


We also provide multiple command line interface options using PyTLidar.treeqsm and PyTLidar.treeqsm_batch

You may run the following your terminal

```
python -m PyTLidar.treeqsm file.las
```
or to run a full folder of las files in batch mode
```
python -m PyTLidar.treeqsm_batch folder
```
The below arguments can also be passed to provide full functionality 

    -intensity: filter point cloud based on values greater than the indicated intensity

    -normalize: recenter point cloud locations. Use this if your point cloud X, Y location values are very large (e.g., using UTM coordinates rather than a local coordinate system).

    -custominput: user sets specific patch diameters to test

    -ipd: initial patch diameter

    -minpd: min patch diameter

    -maxpd: maximum patch diameter

    -name: specifies a name for the current modeling run. This will be appended to the name generated by PyTLidar

    -outputdirectory: specifies the directory to put the "results" folder

    -numcores: specify number of cores to use to process files in parallel. Only valid in batched mode, Must be a single integer

    -optimum: specify an optimum metric to select best model to save 

    -help: displays the run options

    -verbose: verbose mode, displays outputs from PyTLidar as it processes

    -h: displays the run options

    -v: verbose mode

Examples:

1. Create a QSM for a single file, normalizing the file, and using 2 initial patch diameter values generated based on structural assumptions
```
python -m PyTLidar.treeqsm file.las --normalize --ipd 2
```
2.  Create a QSM for multiple files, with normalization, testing a specific set of patch diameter values, saving only the best model based on lowest mean distance to trunk
```
python -m PyTLidar.treeqsm_batch folder --normalize --custominput --ipd .05 .08 --minpd .03 .05 --maxpd .1 --optimum trunk_mean_dis
```

### TreeQSM Module Quick Start

The TreeQSM module can be used directly as well if you need more customization of the output data or direct connection to the objects. Further information on each of these functions' inputs and outputs can be found in ![core_api.md].

Below is the algorithm sequence of the TreeQSM process on a single file and testing a single set of values. See treeqsm.py for a full implementation. This sequence must always be performed in this order, with very little room for change, but exposes all of the objects for use in your own pipelines.


The first steps of the process are to load your .las/.laz file. This should be a single tree with no/minimal non-tree points. If not already, these points should be normalized  around an average origin to minimize floating point precision errors often encountered using direct coordinates. You should then run define_input(). This will create the structure to input parameter to change and customize. You may also utilize it to auto-calculate the input parameters to run.

```
import PyTLidar.treeqsm as qsm


file = 'example_pine.las'

P = qsm.Utils.load_point_cloud(file) #Load las file

P = P - np.mean(P,axis = 0) #Normalize points

Inputs = define_input(P, 1, 1, 1)[0] #Create input parameter structure
```

If you'd like to customize the input parameters, the below are all customizable. All except 'plot' are parameters that will impact the actual ouput. 'plot' controls whether outputs will be auto-displayed or only saved for later.

```
# Inputs can be specified 
Inputs['PatchDiam1'] = [0.05] #Initial size of cover sets, lower values will capture more detail, but are more susceptible to occlusion
Inputs['PatchDiam2Min'] = [0.03] #Minimum cover set size for second pass
Inputs['PatchDiam2Max'] = [0.12] #Maximum cover set size for second pass
Inputs['BallRad1'] = [0.06] #radius around cover set midpoint to check for neighbors, should be slightly larger than PatchDiam1
Inputs['BallRad2'] = [0.13] #Ball Radius for second pass, should be slightly larger than PatchDiam2Max
Inputs['plot'] = 0 #Flag for plot generation during runtime
```

The core of the algorithm is the below sequence. This should only be modified if you have a solid understanding of the relationships between the objects created and modified by the functions. See ![core_api.md]{core_api.md} for more details.

```
cover1 = qsm.cover_sets(P,Inputs) #Generate initial cover sets and neighbors
cover1, Base, Forb = qsm.tree_sets(P, cover1, Inputs) #Tree set generation/detection of base points
segment1 = qsm.segments(cover1,Base,Forb) #Segment generation
segment1 = qsm.correct_segments(P,cover1,segment1,Inputs,0,1,1) #Segment Correction
RS = qsm.relative_size(P, cover1, segment1) #Calculation of relative size for generation of new cover sets
cover2 = qsm.cover_sets(P, Inputs, RS) # Cover set Generation, 2nd Pass
cover2, Base, Forb = qsm.tree_sets(P, cover2, Inputs, segment1) # Tree set generation
segment2 = qsm.segments(cover2, Base, Forb) #Segment Generation, 2nd Pass
segment2 = qsm.correct_segments(P, cover2, segment2, Inputs, 1, 1, 0)#Segment correction, 2nd Pass
cylinder = qsm.cylinders(P,cover2,segment2,Inputs) #Fit Cylinders
```

Once the qsm is built, data can be extracted using the below. This will give you the standard metrics delivered by the other methods.

```
branch = qsm.branches(cylinder)#Calculate branch metrics
#Extract Trunk points:
T = segment2['segments'][0]  
T = np.concatenate(T)  
T = np.concatenate([cover2['ball'][idx] for idx in T]) 
trunk = P[T, :]  # Point cloud of the trunk
treedata, _ = qsm.tree_data(cylinder, branch, trunk, inputs,iter )

```
# Tests

Run the tests using pytest:
```
pytest
```

This will run all the test cases under the tests/ directory. The tests include basic functionality checks for the core components of QSM creation.

You can also run specific tests by passing the test file or function name:

pytest tests/test_calculate.py

Due to the complex nature of inputs and outputs of the algorithm, manual tests are also recommended. Using Dataset/example_pine.las run:

```
python -m PyTLidar.treeqsm example_pine.las --normalize --verbose 
```

Compare the tree_data_Tree1_t1_m1.txt file that is generated to Dataset/results/example_pine_tree_data.txt. The algorithm is randomized, so many values will not match, but no value should be significantly different. 

This test can also be run using the GUI, and a visual check can also be done as a sanity check on the resulting numbers.





